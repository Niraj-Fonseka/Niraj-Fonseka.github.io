export const items = {
    "status": "ok",
    "feed": {
        "url": "https://medium.com/feed/@fonseka.live",
        "title": "Stories by Niraj Fonseka on Medium",
        "link": "https://medium.com/@fonseka.live?source=rss-d76a6b2861ea------2",
        "author": "",
        "description": "Stories by Niraj Fonseka on Medium",
        "image": "https://cdn-images-1.medium.com/fit/c/150/150/1*XEJzPiBE_NC_mtHnZ2dd1A@2x.jpeg"
    },
    "items": [
        {
            "title": "Building a realtime dashboard with ReactJS, Go, gRPC, and Envoy.",
            "pubDate": "2020-06-19 06:47:17",
            "link": "https://medium.com/swlh/building-a-realtime-dashboard-with-reactjs-go-grpc-and-envoy-7be155dfabfb?source=rss-d76a6b2861ea------2",
            "guid": "https://medium.com/p/7be155dfabfb",
            "author": "Niraj Fonseka",
            "thumbnail": "https://cdn-images-1.medium.com/max/700/1*8fzv65hIl3-AvqUlbmYmpA.png",
            "description": "<div class=\"medium-feed-item\">\n<p class=\"medium-feed-image\"><a href=\"https://medium.com/swlh/building-a-realtime-dashboard-with-reactjs-go-grpc-and-envoy-7be155dfabfb?source=rss-d76a6b2861ea------2\"><img src=\"https://cdn-images-1.medium.com/max/700/1*8fzv65hIl3-AvqUlbmYmpA.png\" width=\"700\"></a></p>\n<p class=\"medium-feed-snippet\">Before we start, you can find all the code related to this article in this repository.</p>\n<p class=\"medium-feed-link\"><a href=\"https://medium.com/swlh/building-a-realtime-dashboard-with-reactjs-go-grpc-and-envoy-7be155dfabfb?source=rss-d76a6b2861ea------2\">Continue reading on The Startup »</a></p>\n</div>",
            "content": "<div class=\"medium-feed-item\">\n<p class=\"medium-feed-image\"><a href=\"https://medium.com/swlh/building-a-realtime-dashboard-with-reactjs-go-grpc-and-envoy-7be155dfabfb?source=rss-d76a6b2861ea------2\"><img src=\"https://cdn-images-1.medium.com/max/700/1*8fzv65hIl3-AvqUlbmYmpA.png\" width=\"700\"></a></p>\n<p class=\"medium-feed-snippet\">Before we start, you can find all the code related to this article in this repository.</p>\n<p class=\"medium-feed-link\"><a href=\"https://medium.com/swlh/building-a-realtime-dashboard-with-reactjs-go-grpc-and-envoy-7be155dfabfb?source=rss-d76a6b2861ea------2\">Continue reading on The Startup »</a></p>\n</div>",
            "enclosure": {},
            "categories": [
                "web-development",
                "envoy-proxy",
                "grpc",
                "golang",
                "reactjs"
            ]
        },
        {
            "title": "Detect faces using Golang and OpenCV",
            "pubDate": "2019-07-29 14:01:06",
            "link": "https://medium.com/swlh/detect-faces-using-golang-and-opencv-fbe7a48db055?source=rss-d76a6b2861ea------2",
            "guid": "https://medium.com/p/fbe7a48db055",
            "author": "Niraj Fonseka",
            "thumbnail": "https://cdn-images-1.medium.com/max/600/1*RCF4tL5lVdRP2u3AbxGIlg.png",
            "description": "<div class=\"medium-feed-item\">\n<p class=\"medium-feed-image\"><a href=\"https://medium.com/swlh/detect-faces-using-golang-and-opencv-fbe7a48db055?source=rss-d76a6b2861ea------2\"><img src=\"https://cdn-images-1.medium.com/max/600/1*RCF4tL5lVdRP2u3AbxGIlg.png\" width=\"600\"></a></p>\n<p class=\"medium-feed-snippet\">OpenCV is a library made for computer vision that has been around for almost 20 years. I’ve used through college and for personal projects…</p>\n<p class=\"medium-feed-link\"><a href=\"https://medium.com/swlh/detect-faces-using-golang-and-opencv-fbe7a48db055?source=rss-d76a6b2861ea------2\">Continue reading on The Startup »</a></p>\n</div>",
            "content": "<div class=\"medium-feed-item\">\n<p class=\"medium-feed-image\"><a href=\"https://medium.com/swlh/detect-faces-using-golang-and-opencv-fbe7a48db055?source=rss-d76a6b2861ea------2\"><img src=\"https://cdn-images-1.medium.com/max/600/1*RCF4tL5lVdRP2u3AbxGIlg.png\" width=\"600\"></a></p>\n<p class=\"medium-feed-snippet\">OpenCV is a library made for computer vision that has been around for almost 20 years. I’ve used through college and for personal projects…</p>\n<p class=\"medium-feed-link\"><a href=\"https://medium.com/swlh/detect-faces-using-golang-and-opencv-fbe7a48db055?source=rss-d76a6b2861ea------2\">Continue reading on The Startup »</a></p>\n</div>",
            "enclosure": {},
            "categories": [
                "go",
                "opencv",
                "object-detection",
                "golang",
                "programming"
            ]
        },
        {
            "title": "Sharing data in GitHub Actions",
            "pubDate": "2019-05-02 14:01:01",
            "link": "https://medium.com/@fonseka.live/sharing-data-in-github-actions-a9841a9a6f42?source=rss-d76a6b2861ea------2",
            "guid": "https://medium.com/p/a9841a9a6f42",
            "author": "Niraj Fonseka",
            "thumbnail": "https://cdn-images-1.medium.com/max/504/1*bQhixK5Pumsl1ueAPfgTXA.png",
            "description": "\n<p>In this short article I will show you how to share data between two or more <a href=\"https://developer.github.com/actions/managing-workflows/workflow-configuration-options/#action-blocks\">action blocks.</a> If you would like an introduction to GitHub actions you can check out one of my <a href=\"https://medium.com/@fonseka.live/github-actions-hands-on-51d48eeca7ee\">previous articles</a>.</p>\n<p><strong>Problem</strong></p>\n<p>When I was playing around with GitHub actions for one of my personal projects I wanted to do some work in one action-block and pass it on to the other so it can use the result from the first block to do some other task in the second block.</p>\n<p>First let’s take a look at the <a href=\"https://developer.github.com/actions/creating-github-actions/accessing-the-runtime-environment/\">GitHub Actions runtime environment</a>.</p>\n<p>All the action blocks in a workflow gets executed in an environment with ( 1 CPU , Up to 3.75 GB of memory , Remote network access , Environment variables, Write access to the <a href=\"https://developer.github.com/actions/creating-github-actions/accessing-the-runtime-environment/#filesystem\">filesystem</a> and 100 GB of disk space. Follow this <a href=\"https://developer.github.com/actions/creating-github-actions/accessing-the-runtime-environment/\">link</a> to read more about it.</p>\n<p><strong>Example</strong></p>\n<p>For this example I will create two GitHub Actions called <em>action1</em> and <em>action2. </em>Then, I will attempt to build a message from action1 and pass it on to action2. The overall workflow will look like this.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/504/1*bQhixK5Pumsl1ueAPfgTXA.png\"></figure><p>When the workflow runs to completion we should should see this in the log output of action2.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/792/1*SZ2J1S6zegBlR8ydY9HJoA.png\"></figure><p><strong>Solution</strong></p>\n<p>At first I tried to use the <a href=\"https://developer.github.com/actions/creating-github-actions/accessing-the-runtime-environment/#environment-variables\">environment variables</a> to share data between the two actions but after a few experiments it seemed like the environment variables were getting reset when switching from one action block to the next.</p>\n<p>This is where the shared filesystem came in handy. As I mentioned before the GitHub action runtime gives us the write access to it’s filesystem and 100GB of disk space. We can use this to store data from one action and read that data from a different action.</p>\n<p>In this case, when action1 executes it will store the message in a file called data.txt in the /github/home directory. And then when action2 executes, it will extract the message from that file and print it.</p>\n<p>Here are the entrypoint.sh files for both of the actions. Follow this <a href=\"https://developer.github.com/actions/creating-github-actions/creating-a-new-action/\">link</a> to find more information about how to write custom GitHub actions.</p>\n<p><strong>action1</strong></p>\n<pre>#!/bin/bash </pre>\n<pre>echo \"Action 1 Running\"</pre>\n<pre>echo \"message from action 1\" &gt;&gt; /github/home/data.txt </pre>\n<pre>echo \"Action 1 Done\"</pre>\n<p><strong>action2</strong></p>\n<pre>#!/bin/bash </pre>\n<pre>echo \"Action 2 Running\" </pre>\n<pre>value=$(cat /github/home/data.txt) </pre>\n<pre>echo $value echo \"Action 2 Done\"</pre>\n<p>You can find the code for this example in <a href=\"https://github.com/Niraj-Fonseka/GitHubActions-Share-Memory\">GitHub</a>. Thank you for reading :)</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a9841a9a6f42\" width=\"1\" height=\"1\" alt=\"\">\n",
            "content": "\n<p>In this short article I will show you how to share data between two or more <a href=\"https://developer.github.com/actions/managing-workflows/workflow-configuration-options/#action-blocks\">action blocks.</a> If you would like an introduction to GitHub actions you can check out one of my <a href=\"https://medium.com/@fonseka.live/github-actions-hands-on-51d48eeca7ee\">previous articles</a>.</p>\n<p><strong>Problem</strong></p>\n<p>When I was playing around with GitHub actions for one of my personal projects I wanted to do some work in one action-block and pass it on to the other so it can use the result from the first block to do some other task in the second block.</p>\n<p>First let’s take a look at the <a href=\"https://developer.github.com/actions/creating-github-actions/accessing-the-runtime-environment/\">GitHub Actions runtime environment</a>.</p>\n<p>All the action blocks in a workflow gets executed in an environment with ( 1 CPU , Up to 3.75 GB of memory , Remote network access , Environment variables, Write access to the <a href=\"https://developer.github.com/actions/creating-github-actions/accessing-the-runtime-environment/#filesystem\">filesystem</a> and 100 GB of disk space. Follow this <a href=\"https://developer.github.com/actions/creating-github-actions/accessing-the-runtime-environment/\">link</a> to read more about it.</p>\n<p><strong>Example</strong></p>\n<p>For this example I will create two GitHub Actions called <em>action1</em> and <em>action2. </em>Then, I will attempt to build a message from action1 and pass it on to action2. The overall workflow will look like this.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/504/1*bQhixK5Pumsl1ueAPfgTXA.png\"></figure><p>When the workflow runs to completion we should should see this in the log output of action2.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/792/1*SZ2J1S6zegBlR8ydY9HJoA.png\"></figure><p><strong>Solution</strong></p>\n<p>At first I tried to use the <a href=\"https://developer.github.com/actions/creating-github-actions/accessing-the-runtime-environment/#environment-variables\">environment variables</a> to share data between the two actions but after a few experiments it seemed like the environment variables were getting reset when switching from one action block to the next.</p>\n<p>This is where the shared filesystem came in handy. As I mentioned before the GitHub action runtime gives us the write access to it’s filesystem and 100GB of disk space. We can use this to store data from one action and read that data from a different action.</p>\n<p>In this case, when action1 executes it will store the message in a file called data.txt in the /github/home directory. And then when action2 executes, it will extract the message from that file and print it.</p>\n<p>Here are the entrypoint.sh files for both of the actions. Follow this <a href=\"https://developer.github.com/actions/creating-github-actions/creating-a-new-action/\">link</a> to find more information about how to write custom GitHub actions.</p>\n<p><strong>action1</strong></p>\n<pre>#!/bin/bash </pre>\n<pre>echo \"Action 1 Running\"</pre>\n<pre>echo \"message from action 1\" &gt;&gt; /github/home/data.txt </pre>\n<pre>echo \"Action 1 Done\"</pre>\n<p><strong>action2</strong></p>\n<pre>#!/bin/bash </pre>\n<pre>echo \"Action 2 Running\" </pre>\n<pre>value=$(cat /github/home/data.txt) </pre>\n<pre>echo $value echo \"Action 2 Done\"</pre>\n<p>You can find the code for this example in <a href=\"https://github.com/Niraj-Fonseka/GitHubActions-Share-Memory\">GitHub</a>. Thank you for reading :)</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=a9841a9a6f42\" width=\"1\" height=\"1\" alt=\"\">\n",
            "enclosure": {},
            "categories": [
                "docker",
                "github",
                "github-actions",
                "automation",
                "continuous-integration"
            ]
        },
        {
            "title": "setkubecontext : change your kubernetes contexts easily",
            "pubDate": "2019-02-18 13:01:01",
            "link": "https://medium.com/@fonseka.live/setkubecontext-change-your-kubernetes-contexts-easily-f97c43517b67?source=rss-d76a6b2861ea------2",
            "guid": "https://medium.com/p/f97c43517b67",
            "author": "Niraj Fonseka",
            "thumbnail": "https://cdn-images-1.medium.com/max/1024/1*HV5dg6EUcqIyuEYSYNfSRQ.png",
            "description": "\n<h3>\n<strong>setkubecontext</strong> : change your kubernetes contexts easily</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HV5dg6EUcqIyuEYSYNfSRQ.png\"></figure><p>When I was working with multiple Kubernetes clusters I always found that the process of changing context using the <em>kubectl</em> cli from cluster to cluster very time consuming. Most of the time I ended up using</p>\n<p>kubectl config use &lt;context_name&gt;</p>\n<p>But this was quite frustrating especially when I had to deal with more than two or three clusters. This made me write a very simple application to make my life easier and save some time.</p>\n<p><strong>Installation</strong></p>\n<p><em>Pre-reqs : kubernetes CLI ( kubectl )</em></p>\n<p>if you have Go installed already</p>\n<pre>go get -u github.com/Niraj-Fonseka/setkubecontext</pre>\n<p>and then move the setkubecontext binary into /usr/local/bin</p>\n<pre>cp $GOPATH/bin/setkubecontext /usr/local/bin</pre>\n<p>or you can download the binary directly from the releases section in the <a href=\"https://github.com/Niraj-Fonseka/setkubecontext/releases\">repository</a>.</p>\n<p><strong>How it works</strong></p>\n<p>Type setkubecontext on your terminal. Then you will be presented with all the kubernetes contexts that are saved in your machine.</p>\n<pre>(0) docker-for-desktop<br>(1) minikube<br>(2) cluster-1<br>(3) cluster-2<br>(4) cluster-3<br>(5) gke-cluster-name-1</pre>\n<p>Then type the number of the context that you would like to change your current context to.</p>\n<p>That’s it !</p>\n<pre>Enter the number of the cluster: 2<br>Switched to context \"cluster-1\".</pre>\n<pre>***  Kubernetes context has changed from minikube to cluster-1 ***</pre>\n<p>The code for this application is available in <a href=\"https://github.com/Niraj-Fonseka/setkubecontext\">GitHub</a>.</p>\n<p>p.s</p>\n<p>I wrote this application a few months ago to solve a simple problem that I kept encountering daily. Finally decided to write an article about it because for the last few months I’ve been using this often and it has saved me quite a bit of time. If you have any suggestions to improve this application please feel free to reach out.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f97c43517b67\" width=\"1\" height=\"1\" alt=\"\">\n",
            "content": "\n<h3>\n<strong>setkubecontext</strong> : change your kubernetes contexts easily</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HV5dg6EUcqIyuEYSYNfSRQ.png\"></figure><p>When I was working with multiple Kubernetes clusters I always found that the process of changing context using the <em>kubectl</em> cli from cluster to cluster very time consuming. Most of the time I ended up using</p>\n<p>kubectl config use &lt;context_name&gt;</p>\n<p>But this was quite frustrating especially when I had to deal with more than two or three clusters. This made me write a very simple application to make my life easier and save some time.</p>\n<p><strong>Installation</strong></p>\n<p><em>Pre-reqs : kubernetes CLI ( kubectl )</em></p>\n<p>if you have Go installed already</p>\n<pre>go get -u github.com/Niraj-Fonseka/setkubecontext</pre>\n<p>and then move the setkubecontext binary into /usr/local/bin</p>\n<pre>cp $GOPATH/bin/setkubecontext /usr/local/bin</pre>\n<p>or you can download the binary directly from the releases section in the <a href=\"https://github.com/Niraj-Fonseka/setkubecontext/releases\">repository</a>.</p>\n<p><strong>How it works</strong></p>\n<p>Type setkubecontext on your terminal. Then you will be presented with all the kubernetes contexts that are saved in your machine.</p>\n<pre>(0) docker-for-desktop<br>(1) minikube<br>(2) cluster-1<br>(3) cluster-2<br>(4) cluster-3<br>(5) gke-cluster-name-1</pre>\n<p>Then type the number of the context that you would like to change your current context to.</p>\n<p>That’s it !</p>\n<pre>Enter the number of the cluster: 2<br>Switched to context \"cluster-1\".</pre>\n<pre>***  Kubernetes context has changed from minikube to cluster-1 ***</pre>\n<p>The code for this application is available in <a href=\"https://github.com/Niraj-Fonseka/setkubecontext\">GitHub</a>.</p>\n<p>p.s</p>\n<p>I wrote this application a few months ago to solve a simple problem that I kept encountering daily. Finally decided to write an article about it because for the last few months I’ve been using this often and it has saved me quite a bit of time. If you have any suggestions to improve this application please feel free to reach out.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=f97c43517b67\" width=\"1\" height=\"1\" alt=\"\">\n",
            "enclosure": {},
            "categories": [
                "infrastructure",
                "kubernetes",
                "k8s",
                "golang",
                "open-source"
            ]
        },
        {
            "title": "Github Actions : Hands On",
            "pubDate": "2019-02-13 13:11:25",
            "link": "https://medium.com/@fonseka.live/github-actions-hands-on-51d48eeca7ee?source=rss-d76a6b2861ea------2",
            "guid": "https://medium.com/p/51d48eeca7ee",
            "author": "Niraj Fonseka",
            "thumbnail": "https://cdn-images-1.medium.com/max/1024/1*bRMgyTY9ZQYWWtdNdZpqmw.jpeg",
            "description": "\n<h3>Github Actions : Hands On</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*bRMgyTY9ZQYWWtdNdZpqmw.jpeg\"><figcaption><a href=\"https://culturainteractive.com/wp-content/uploads/2016/01/Action-Button-.jpg\">https://culturainteractive.com/wp-content/uploads/2016/01/Action-Button-.jpg</a></figcaption></figure><p>After waiting what felt like many many months, last week I finally got access to Github actions beta. This new tool by Github allows you to run a set of tasks from a Github platform trigger such as a push or a commit. Github calls these sets of tasks as workflows. Personally One of the biggest headaches I’ve had when creating an application is setting up a CI/CD pipeline. Previously I’ve used CircleCI or TravisCI for this but I wasn’t a big fan of this because it required taking extra steps such as moving around tokens to get access to github repositories , changing configurations in the CI/CD platform and Github etc. With Github actions I won’t have to worry about this anymore because it finally allows me to create CI/CD workloads integrated into my Github repository. <br>The workflow is defined in a file called main.workflow. You can modify your workflow by using the GUI or by manually editing the file. Also since Github actions are still on beta, it’s not perfect. There were few times that I ran into issues when I manually edited the file but those edits didn't reflect when I converted back into the GUI.</p>\n<p><strong>main.workflow</strong></p>\n<p>An action, which is one step in the workflow is defined in a code block. Depending on what action you would like to use the arguments the action takes in varies.</p>\n<pre>workflow \"Deploy\" {<br>  on = \"push\"<br>  resolves = [<br>    \"GitHub Action for Slack\",<br>  ]<br>}<br><br>action \"Build docker image \" {<br>  uses = \"actions/docker/cli@aea64bb1b97c42fa69b90523667fef56b90d7cff\"<br>  args = [\"build\", \"-t\", \"githubactions\", \".\"]<br>}<br><br>action \"Get Auth for Google Cloud\" {<br>  uses = \"actions/gcloud/auth@df59b3263b6597df4053a74e4e4376c045d9087e\"<br>  secrets = [\"GCLOUD_AUTH\"]<br>}</pre>\n<pre>...<br>...<br>...</pre>\n<p>In the GUI mode these code blocks get converted into a flow diagram.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*DFnaaFxbnLLtQ0SCWhqBhA.png\"></figure><p>There are many Github actions provided to you by Github. You can use them to build your workflow.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*e2RneoTsMQQtFljypz1_PA.png\"></figure><p>If you can not find the action that fits your task, you can look in <a href=\"https://github.com/marketplace/actions\">Github Marketplace</a>. The market place allows users to share their own creations as well. Or you can always <a href=\"https://developer.github.com/actions/creating-github-actions/creating-a-new-action/\">create your own </a>custom action.</p>\n<p><strong>The Example</strong></p>\n<p>In this example I’m trying to create a workflow to deploy my Go web application to GKE on push to the master branch of my Github repository.</p>\n<p><em>You can find the code for this example </em><a href=\"https://github.com/Niraj-Fonseka/GitHubActionsBeta\"><em>here</em></a></p>\n<p>I’ve explained each step of the workflow below.</p>\n<ol>\n<li>Build the Docker image and tag it and set up google cloud.</li>\n<li>Tag the Docker image from stage #1 to push to Google Container Registry ( GCR )</li>\n<li>Set credentials for Docker before pushing to google container Google Container Registry</li>\n<li>Push image to Google Container Registry</li>\n<li>Set up authentication credentials for the Kubernetes (k8s) cluster</li>\n<li>Use the <a href=\"https://github.com/Niraj-Fonseka/GitHubActionsBeta/blob/master/deploy.yml\">deploy.yml</a> file to replace the deployment in the K8s</li>\n<li>Then send a slack message to a slack channel notifying that the deployment is completed using a slack web-hook.</li>\n</ol>\n<p>Now let’s do a quick demo.</p>\n<p>For this demo i’ll be adding a new route to the application called /githubactions that returns the string “Hello From GitHub Actions”. As you can see, as of right now that endpoint doesn’t exist.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/858/1*YiOEHfVBIhIZITbkT0kCyA.jpeg\"></figure><p>Now let’s add the new route to the application and push the code to master.</p>\n<pre>package main</pre>\n<pre>import (<br>   \"fmt\"<br>   \"net/http\"<br>)</pre>\n<pre>func main() {</pre>\n<pre>      http.HandleFunc(\"/githubactions\", func(w http.ResponseWriter, r *http.Request) {</pre>\n<pre>              fmt.Fprintf(w, \"Hello From GitHub Actions\")</pre>\n<pre>      })</pre>\n<pre>      http.ListenAndServe(\":8080\", nil)</pre>\n<pre>}</pre>\n<p>Now let’s take a look at our workflow.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/1*yxzJpYYorO6O5GfWJi_TNQ.gif\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*EgdQM11B3IhbWCaTjg5PvQ.gif\"></figure><p><strong>In Slack :</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*JGUUBibDsKjX2Fc1w_6VSg.png\"></figure><p>Great ! looks like the deployment completed successfully. Now let’s go check if the the route we added is accessible.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/982/1*Lzg8haxLKMDGbKSefICerw.jpeg\"></figure><p>I’ve used Github actions for just a few days and I’m already really liking it. It was fairly easy to get started and create complicated workflows even with the little documentation available at the moment. I believe this has a lot of potential and I’m definitely planning on using this for my future projects.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=51d48eeca7ee\" width=\"1\" height=\"1\" alt=\"\">\n",
            "content": "\n<h3>Github Actions : Hands On</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*bRMgyTY9ZQYWWtdNdZpqmw.jpeg\"><figcaption><a href=\"https://culturainteractive.com/wp-content/uploads/2016/01/Action-Button-.jpg\">https://culturainteractive.com/wp-content/uploads/2016/01/Action-Button-.jpg</a></figcaption></figure><p>After waiting what felt like many many months, last week I finally got access to Github actions beta. This new tool by Github allows you to run a set of tasks from a Github platform trigger such as a push or a commit. Github calls these sets of tasks as workflows. Personally One of the biggest headaches I’ve had when creating an application is setting up a CI/CD pipeline. Previously I’ve used CircleCI or TravisCI for this but I wasn’t a big fan of this because it required taking extra steps such as moving around tokens to get access to github repositories , changing configurations in the CI/CD platform and Github etc. With Github actions I won’t have to worry about this anymore because it finally allows me to create CI/CD workloads integrated into my Github repository. <br>The workflow is defined in a file called main.workflow. You can modify your workflow by using the GUI or by manually editing the file. Also since Github actions are still on beta, it’s not perfect. There were few times that I ran into issues when I manually edited the file but those edits didn't reflect when I converted back into the GUI.</p>\n<p><strong>main.workflow</strong></p>\n<p>An action, which is one step in the workflow is defined in a code block. Depending on what action you would like to use the arguments the action takes in varies.</p>\n<pre>workflow \"Deploy\" {<br>  on = \"push\"<br>  resolves = [<br>    \"GitHub Action for Slack\",<br>  ]<br>}<br><br>action \"Build docker image \" {<br>  uses = \"actions/docker/cli@aea64bb1b97c42fa69b90523667fef56b90d7cff\"<br>  args = [\"build\", \"-t\", \"githubactions\", \".\"]<br>}<br><br>action \"Get Auth for Google Cloud\" {<br>  uses = \"actions/gcloud/auth@df59b3263b6597df4053a74e4e4376c045d9087e\"<br>  secrets = [\"GCLOUD_AUTH\"]<br>}</pre>\n<pre>...<br>...<br>...</pre>\n<p>In the GUI mode these code blocks get converted into a flow diagram.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*DFnaaFxbnLLtQ0SCWhqBhA.png\"></figure><p>There are many Github actions provided to you by Github. You can use them to build your workflow.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*e2RneoTsMQQtFljypz1_PA.png\"></figure><p>If you can not find the action that fits your task, you can look in <a href=\"https://github.com/marketplace/actions\">Github Marketplace</a>. The market place allows users to share their own creations as well. Or you can always <a href=\"https://developer.github.com/actions/creating-github-actions/creating-a-new-action/\">create your own </a>custom action.</p>\n<p><strong>The Example</strong></p>\n<p>In this example I’m trying to create a workflow to deploy my Go web application to GKE on push to the master branch of my Github repository.</p>\n<p><em>You can find the code for this example </em><a href=\"https://github.com/Niraj-Fonseka/GitHubActionsBeta\"><em>here</em></a></p>\n<p>I’ve explained each step of the workflow below.</p>\n<ol>\n<li>Build the Docker image and tag it and set up google cloud.</li>\n<li>Tag the Docker image from stage #1 to push to Google Container Registry ( GCR )</li>\n<li>Set credentials for Docker before pushing to google container Google Container Registry</li>\n<li>Push image to Google Container Registry</li>\n<li>Set up authentication credentials for the Kubernetes (k8s) cluster</li>\n<li>Use the <a href=\"https://github.com/Niraj-Fonseka/GitHubActionsBeta/blob/master/deploy.yml\">deploy.yml</a> file to replace the deployment in the K8s</li>\n<li>Then send a slack message to a slack channel notifying that the deployment is completed using a slack web-hook.</li>\n</ol>\n<p>Now let’s do a quick demo.</p>\n<p>For this demo i’ll be adding a new route to the application called /githubactions that returns the string “Hello From GitHub Actions”. As you can see, as of right now that endpoint doesn’t exist.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/858/1*YiOEHfVBIhIZITbkT0kCyA.jpeg\"></figure><p>Now let’s add the new route to the application and push the code to master.</p>\n<pre>package main</pre>\n<pre>import (<br>   \"fmt\"<br>   \"net/http\"<br>)</pre>\n<pre>func main() {</pre>\n<pre>      http.HandleFunc(\"/githubactions\", func(w http.ResponseWriter, r *http.Request) {</pre>\n<pre>              fmt.Fprintf(w, \"Hello From GitHub Actions\")</pre>\n<pre>      })</pre>\n<pre>      http.ListenAndServe(\":8080\", nil)</pre>\n<pre>}</pre>\n<p>Now let’s take a look at our workflow.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/640/1*yxzJpYYorO6O5GfWJi_TNQ.gif\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/480/1*EgdQM11B3IhbWCaTjg5PvQ.gif\"></figure><p><strong>In Slack :</strong></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*JGUUBibDsKjX2Fc1w_6VSg.png\"></figure><p>Great ! looks like the deployment completed successfully. Now let’s go check if the the route we added is accessible.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/982/1*Lzg8haxLKMDGbKSefICerw.jpeg\"></figure><p>I’ve used Github actions for just a few days and I’m already really liking it. It was fairly easy to get started and create complicated workflows even with the little documentation available at the moment. I believe this has a lot of potential and I’m definitely planning on using this for my future projects.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=51d48eeca7ee\" width=\"1\" height=\"1\" alt=\"\">\n",
            "enclosure": {},
            "categories": [
                "github",
                "github-actions",
                "docker",
                "continuous-delivery",
                "continuous-integration"
            ]
        },
        {
            "title": "Multi-stage Docker Builds in Golang with Go Modules",
            "pubDate": "2019-02-07 12:17:51",
            "link": "https://levelup.gitconnected.com/multi-stage-docker-builds-with-go-modules-df23b7f91a67?source=rss-d76a6b2861ea------2",
            "guid": "https://medium.com/p/df23b7f91a67",
            "author": "Niraj Fonseka",
            "thumbnail": "https://cdn-images-1.medium.com/max/1024/1*HeYkLXfPu1uA-xFuW2n5zA.png",
            "description": "\n<h4>A tutorial on multi-stage Docker builds with Go using Go Modules and how to reduce the Docker image size by hundreds of megabytes</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HeYkLXfPu1uA-xFuW2n5zA.png\"></figure><p>In this article I will give you a quick walkthrough on how to create smaller Docker images for Go applications that use Go modules. You can find all the code for this article in this <a href=\"https://github.com/Niraj-Fonseka/MultiStageDocker\">repository</a>.</p>\n<p>In a traditional Docker build for a Go app, it’s pretty common to use the <a href=\"https://hub.docker.com/_/golang\">Golang</a> image. While this is perfectly fine, these images tend to be quite large due to the size of the Golang image itself. Let’s look at an example to see how we can reduce our image size by hundreds of megabytes.</p>\n<blockquote>In my example, I’ll be using Go Modules for dependency management. If you are unfamiliar with Go Modules, feel free to check out my previous article on <a href=\"https://medium.com/@fonseka.live/getting-started-with-go-modules-b3dac652066d\">Go Modules</a>.</blockquote>\n<p>Let’s consider this is the app we would like to dockerize.</p>\n<pre>package main<br><br>import (<br>\t\"fmt\"<br><br>\trandomdata \"github.com/Pallinder/go-randomdata\"<br>)<br><br>func main() {<br>\tfmt.Println(\"Running the TestApp\")<br>\tfmt.Println(randomdata.SillyName())<br>}</pre>\n<p>And this is our Dockerfile:</p>\n<pre>FROM golang:1.11.0-stretch <br><br>COPY . /SingleStage <br>WORKDIR /SingleStage<br><br>ENV GO111MODULE=on<br><br>RUN CGO_ENABLED=0 GOOS=linux go build -o SingleStage <br><br>CMD [\"./SingleStage\"]</pre>\n<p>As you can see, we are using golang:1.11 image as the base image to build our app and that GOPATH is not used in the build. That’s because Go 1.11 allows you to build applications outside of the GOPATH.</p>\n<p>Now let’s build the app.</p>\n<pre>docker build -t singlestagebuild .</pre>\n<p>If we run the docker images command and look at the size of the image we can see that even for a very simple app like this the size is almost 800MB.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*5H1BS-UAGCRVOomOrrKGLg.png\"></figure><p>Now let’s see how we can reduce the size of the image using a multi-stage Docker build. I’ll still be using the previous Go app for this demonstration as well.</p>\n<p>This is our new Dockerfile.</p>\n<pre>#first stage - builder</pre>\n<pre>FROM golang:1.11.0-stretch as builder</pre>\n<pre>COPY . /MultiStage</pre>\n<pre>WORKDIR /MultiStage</pre>\n<pre>ENV GO111MODULE=on</pre>\n<pre>RUN CGO_ENABLED=0 GOOS=linux go build -o MultiStage</pre>\n<pre>#second stage</pre>\n<pre>FROM alpine:latest</pre>\n<pre>WORKDIR /root/</pre>\n<pre>COPY --from=builder /MultiStage .</pre>\n<pre>CMD [\"./Multistage\"]</pre>\n<p>In the first stage, we are using the same image that we used in the first example. The only difference is instead of CMD [“./Multistage”], I’m starting up the second stage using an Alpine image and set the working directory to /root/. Then I’m copying all the contents from /MultiStage directory to our builder image (where the binary for the Multistage also exists).</p>\n<p>Let’s build and see how big our image is.</p>\n<pre>docker build -t multistage .</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*sjxeDlCW8fXwkRRZhm8xCA.png\"></figure><p>There we go! Reducing down to 8.15MB from 781MB is a huge size difference.</p>\n<p>The Alpine image that we use as our second stage is an extremely lightweight distribution of Linux. So you will have to be careful because you need to ensure that any of your Go libraries are not using any Linux internal libraries / files that are not included in the Alpine image, and if they do, you must manually add them. Let’s take a look at another example and see this in action.</p>\n<p>In this example, we are trying to get the time in Berlin by using the LoadLocation() function in the time package.</p>\n<pre>package main<br><br>import (<br>\t\"fmt\"<br>\t\"time\"<br>)<br><br>func main() {<br><br>\tlocation, err := time.LoadLocation(\"Europe/Berlin\")<br>\tif err != nil {<br>\t\tfmt.Println(err)<br>\t}<br><br>\tt := time.Now().In(location)<br><br>\tfmt.Println(\"Time in Berlin:\", t.Format(\"02.01.2006 15:04\"))<br>}</pre>\n<p>Now let’s dockerize it and run it.</p>\n<p>docker build -t loadlocation .</p>\n<pre>docker run loadlocation</pre>\n<p>Uh oh…</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*UHmtnDym8eZOGrpMtnhs4Q.png\"></figure><p>Whenever we call the LoadLocation() function in the time package it looks for the “Time Zone Database” (zoneinfo.zip ) which maintains a list of time zone information from locations around the world. Since the alpine image does not have this file we will have to inject it into the image manually.</p>\n<pre>RUN apk add --no-cache tzdata</pre>\n<p>You may need to inject CA root certs into the Alpine image as well. you can do this by using apk.</p>\n<pre>RUN apk --update add ca-certificates</pre>\n<p>Or copying the ca-certs from the builder image (first stage)</p>\n<pre>COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/</pre>\n<p>Now let’s look at the final Dockerfile.</p>\n<pre>#first stage - builder</pre>\n<pre>FROM golang:1.11.0-stretch as builder</pre>\n<pre>COPY . /LoadLocation</pre>\n<pre>WORKDIR /LoadLocation</pre>\n<pre>ENV GO111MODULE=on</pre>\n<pre>RUN CGO_ENABLED=0 GOOS=linux go build -o LoadLocation</pre>\n<pre>#second stage</pre>\n<pre>FROM alpine:latest</pre>\n<pre>WORKDIR /root/</pre>\n<pre>RUN apk add --no-cache tzdata</pre>\n<pre>COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/</pre>\n<pre>COPY --from=builder /LoadLocation .</pre>\n<pre>CMD [\"./LoadLocation\"]</pre>\n<p>Finally, let’s build and run the image.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/738/1*C9hLHCVcXKJUn02zSGLQHg.png\"></figure><p>Perfect!</p>\n<p>I hope this article will help you optimize your docker builds and create more secure (reduced attack surface), smaller (8.15MB vs 781MB), and cleaner images.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*E6CoI_MRyZ1JInNPsBSHtA.png\"></figure><ul>\n<li><a href=\"https://gitconnected.com/learn/docker\">Learn Docker - Best Docker Tutorials (2019) | gitconnected</a></li>\n<li><a href=\"https://gitconnected.com/learn/golang\">Learn Go - Best Go Tutorials (2019) | gitconnected</a></li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=df23b7f91a67\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/multi-stage-docker-builds-with-go-modules-df23b7f91a67\">Multi-stage Docker Builds in Golang with Go Modules</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
            "content": "\n<h4>A tutorial on multi-stage Docker builds with Go using Go Modules and how to reduce the Docker image size by hundreds of megabytes</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*HeYkLXfPu1uA-xFuW2n5zA.png\"></figure><p>In this article I will give you a quick walkthrough on how to create smaller Docker images for Go applications that use Go modules. You can find all the code for this article in this <a href=\"https://github.com/Niraj-Fonseka/MultiStageDocker\">repository</a>.</p>\n<p>In a traditional Docker build for a Go app, it’s pretty common to use the <a href=\"https://hub.docker.com/_/golang\">Golang</a> image. While this is perfectly fine, these images tend to be quite large due to the size of the Golang image itself. Let’s look at an example to see how we can reduce our image size by hundreds of megabytes.</p>\n<blockquote>In my example, I’ll be using Go Modules for dependency management. If you are unfamiliar with Go Modules, feel free to check out my previous article on <a href=\"https://medium.com/@fonseka.live/getting-started-with-go-modules-b3dac652066d\">Go Modules</a>.</blockquote>\n<p>Let’s consider this is the app we would like to dockerize.</p>\n<pre>package main<br><br>import (<br>\t\"fmt\"<br><br>\trandomdata \"github.com/Pallinder/go-randomdata\"<br>)<br><br>func main() {<br>\tfmt.Println(\"Running the TestApp\")<br>\tfmt.Println(randomdata.SillyName())<br>}</pre>\n<p>And this is our Dockerfile:</p>\n<pre>FROM golang:1.11.0-stretch <br><br>COPY . /SingleStage <br>WORKDIR /SingleStage<br><br>ENV GO111MODULE=on<br><br>RUN CGO_ENABLED=0 GOOS=linux go build -o SingleStage <br><br>CMD [\"./SingleStage\"]</pre>\n<p>As you can see, we are using golang:1.11 image as the base image to build our app and that GOPATH is not used in the build. That’s because Go 1.11 allows you to build applications outside of the GOPATH.</p>\n<p>Now let’s build the app.</p>\n<pre>docker build -t singlestagebuild .</pre>\n<p>If we run the docker images command and look at the size of the image we can see that even for a very simple app like this the size is almost 800MB.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*5H1BS-UAGCRVOomOrrKGLg.png\"></figure><p>Now let’s see how we can reduce the size of the image using a multi-stage Docker build. I’ll still be using the previous Go app for this demonstration as well.</p>\n<p>This is our new Dockerfile.</p>\n<pre>#first stage - builder</pre>\n<pre>FROM golang:1.11.0-stretch as builder</pre>\n<pre>COPY . /MultiStage</pre>\n<pre>WORKDIR /MultiStage</pre>\n<pre>ENV GO111MODULE=on</pre>\n<pre>RUN CGO_ENABLED=0 GOOS=linux go build -o MultiStage</pre>\n<pre>#second stage</pre>\n<pre>FROM alpine:latest</pre>\n<pre>WORKDIR /root/</pre>\n<pre>COPY --from=builder /MultiStage .</pre>\n<pre>CMD [\"./Multistage\"]</pre>\n<p>In the first stage, we are using the same image that we used in the first example. The only difference is instead of CMD [“./Multistage”], I’m starting up the second stage using an Alpine image and set the working directory to /root/. Then I’m copying all the contents from /MultiStage directory to our builder image (where the binary for the Multistage also exists).</p>\n<p>Let’s build and see how big our image is.</p>\n<pre>docker build -t multistage .</pre>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*sjxeDlCW8fXwkRRZhm8xCA.png\"></figure><p>There we go! Reducing down to 8.15MB from 781MB is a huge size difference.</p>\n<p>The Alpine image that we use as our second stage is an extremely lightweight distribution of Linux. So you will have to be careful because you need to ensure that any of your Go libraries are not using any Linux internal libraries / files that are not included in the Alpine image, and if they do, you must manually add them. Let’s take a look at another example and see this in action.</p>\n<p>In this example, we are trying to get the time in Berlin by using the LoadLocation() function in the time package.</p>\n<pre>package main<br><br>import (<br>\t\"fmt\"<br>\t\"time\"<br>)<br><br>func main() {<br><br>\tlocation, err := time.LoadLocation(\"Europe/Berlin\")<br>\tif err != nil {<br>\t\tfmt.Println(err)<br>\t}<br><br>\tt := time.Now().In(location)<br><br>\tfmt.Println(\"Time in Berlin:\", t.Format(\"02.01.2006 15:04\"))<br>}</pre>\n<p>Now let’s dockerize it and run it.</p>\n<p>docker build -t loadlocation .</p>\n<pre>docker run loadlocation</pre>\n<p>Uh oh…</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*UHmtnDym8eZOGrpMtnhs4Q.png\"></figure><p>Whenever we call the LoadLocation() function in the time package it looks for the “Time Zone Database” (zoneinfo.zip ) which maintains a list of time zone information from locations around the world. Since the alpine image does not have this file we will have to inject it into the image manually.</p>\n<pre>RUN apk add --no-cache tzdata</pre>\n<p>You may need to inject CA root certs into the Alpine image as well. you can do this by using apk.</p>\n<pre>RUN apk --update add ca-certificates</pre>\n<p>Or copying the ca-certs from the builder image (first stage)</p>\n<pre>COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/</pre>\n<p>Now let’s look at the final Dockerfile.</p>\n<pre>#first stage - builder</pre>\n<pre>FROM golang:1.11.0-stretch as builder</pre>\n<pre>COPY . /LoadLocation</pre>\n<pre>WORKDIR /LoadLocation</pre>\n<pre>ENV GO111MODULE=on</pre>\n<pre>RUN CGO_ENABLED=0 GOOS=linux go build -o LoadLocation</pre>\n<pre>#second stage</pre>\n<pre>FROM alpine:latest</pre>\n<pre>WORKDIR /root/</pre>\n<pre>RUN apk add --no-cache tzdata</pre>\n<pre>COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/</pre>\n<pre>COPY --from=builder /LoadLocation .</pre>\n<pre>CMD [\"./LoadLocation\"]</pre>\n<p>Finally, let’s build and run the image.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/738/1*C9hLHCVcXKJUn02zSGLQHg.png\"></figure><p>Perfect!</p>\n<p>I hope this article will help you optimize your docker builds and create more secure (reduced attack surface), smaller (8.15MB vs 781MB), and cleaner images.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*E6CoI_MRyZ1JInNPsBSHtA.png\"></figure><ul>\n<li><a href=\"https://gitconnected.com/learn/docker\">Learn Docker - Best Docker Tutorials (2019) | gitconnected</a></li>\n<li><a href=\"https://gitconnected.com/learn/golang\">Learn Go - Best Go Tutorials (2019) | gitconnected</a></li>\n</ul>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=df23b7f91a67\" width=\"1\" height=\"1\" alt=\"\"><hr>\n<p><a href=\"https://levelup.gitconnected.com/multi-stage-docker-builds-with-go-modules-df23b7f91a67\">Multi-stage Docker Builds in Golang with Go Modules</a> was originally published in <a href=\"https://levelup.gitconnected.com/\">Level Up Coding</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>\n",
            "enclosure": {},
            "categories": [
                "containers",
                "docker",
                "infrastructure",
                "dockerfiles",
                "golang"
            ]
        },
        {
            "title": "Getting Started with Go modules",
            "pubDate": "2018-12-06 15:02:23",
            "link": "https://medium.com/@fonseka.live/getting-started-with-go-modules-b3dac652066d?source=rss-d76a6b2861ea------2",
            "guid": "https://medium.com/p/b3dac652066d",
            "author": "Niraj Fonseka",
            "thumbnail": "https://cdn-images-1.medium.com/max/1024/1*OJczjavmA1kqrdY_97UvDQ.png",
            "description": "\n<h3>Getting started with Go modules</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OJczjavmA1kqrdY_97UvDQ.png\"></figure><p>Golang is still a fairly new programming language. And dependency management for Go has been a bit tricky since its inception. At the beginning, there was no dependency management system.go get was the only way to download dependencies but this became very tricky because this pulls the code from the master branch of a repository and puts the files into your GOPATH. That means if there were any major changes to any dependencies there’s high likelihood that your code will break. Then tools like dep and concepts such as vendoring came along. Personally I liked dep because it took away a lot of the headaches that came with using go get . But dep was still a third party tool that you had to download to get it to work. But now, with go 1.11things are finally changing.</p>\n<p><strong>So what are Go modules ?</strong></p>\n<p>Go modules in a nutshell is a built-in dependency versioning and dependency management feature for Go. Please note that this is still in experimental stage and the the finalized version will come with go 1.12 .</p>\n<p>In this article I will show you how Go modules work. And also how to move to Go modules if you are currently using dep as your dependency management tool.</p>\n<p>First of all, you will need to make sure that you have Go 1.11 installed. But if you are a fan of docker and don’t want to install Go 1.11 right now you can spin up a Go 1.11 container and use that to play around with Go modules. Also don’t forget to install a text editor when you get inside the docker container.</p>\n<pre>docker run --rm -it golang:1.11</pre>\n<pre>//after you get inside the container </pre>\n<pre>apt-get update &amp;&amp; apt-get install nano</pre>\n<p><strong>Our first application !</strong></p>\n<p>Inside the container you can see that the go path is set to /go</p>\n<pre>root@275af4a4091c:~# echo $GOPATH<br>/go</pre>\n<p>But I’m going to try something that would’ve been very wrong to do in previous Go versions. I’m going to go into my home directory and create a folder for our app called TestApp and set up my app there instead of inside GOPATH.</p>\n<pre>root@275af4a4091c:~# mkdir TestApp<br>root@275af4a4091c:~# ls<br>TestApp</pre>\n<p>Now let’s write our application inside the TestApp folder and name it main.go</p>\n<pre>package main</pre>\n<pre>import (<br> \"fmt\"<br>)</pre>\n<pre>func main(){<br> fmt.Println(\"Running the TestApp\")<br>}</pre>\n<p>Now let’s run it.</p>\n<pre>root@275af4a4091c:~/TestApp# go run main.go<br>Running the TestApp</pre>\n<p>That’s right !! Now we can run Go programs outside of GOPATH !! But this app runs without throwing any errors because it’s only using the fmt library. But let’s try adding a third party library and see how that plays out. I’ll be using <a href=\"https://github.com/Pallinder/go-randomdata\">go-randomdata</a> as our third party library. It lets you generate random data. In this case I’m going to call the function SillyName() after the first print statement.</p>\n<p>This is how the update code looks like.</p>\n<pre>package main</pre>\n<pre>import (<br>        \"fmt\"<br>        \"github.com/Pallinder/go-randomdata\"<br>)</pre>\n<pre>func main(){<br>        fmt.Println(\"Running the TestApp\")<br>        fmt.Println(randomdata.SillyName())<br>}</pre>\n<p>Let’s now run it.</p>\n<pre>root@275af4a4091c:~/TestApp# go run main.go<br>main.go:5:2: cannot find package \"github.com/Pallinder/go-randomdata\" in any of:<br> /usr/local/go/src/github.com/Pallinder/go-randomdata (from $GOROOT)<br> /go/src/github.com/Pallinder/go-randomdata (from $GOPATH)</pre>\n<p>It complains about not finding the package because #1 we are outside of the GOPATH and #2 we haven’t downloaded that package yet. Let’s see how we can use Go modules to fix this. To initialize Go modules in to your application you can run go modules init /path/to/directory</p>\n<pre>root@275af4a4091c:~/TestApp# go mod init /root/TestApp<br>go: creating new go.mod: module /root/TestApp</pre>\n<p>You will see a new file called go.mod gets created in your app directory. Apart from the definition of the module there’s nothing in the go.mod at the moment. To get all the dependencies lets run go build</p>\n<pre>root@275af4a4091c:~/TestApp# go build<br>go: finding github.com/Pallinder/go-randomdata v1.1.0<br>go: downloading github.com/Pallinder/go-randomdata v1.1.0</pre>\n<p>Now let’s take a look at the go.mod file.</p>\n<pre>module /root/TestApp</pre>\n<pre>require github.com/Pallinder/go-randomdata v1.1.0</pre>\n<p>It shows us that in order for our app to run, v1.1.0 is required of the go-randomdata package. After running go build you will also see a file called go.sum gets created. The purpose of this file is to keep track of which codebase of the package you are using. It has a cryptographic hash attached to every dependency we have. This is very helpful if you are working on a busy codebase that multiple people are working on at the same time. If someone is using a different version of a package than the version the app is intended to use, it will complain. If your third party library has multiple versions and you would like to use a different version, you can change the version number and run go build again. Let’s say I would like to use v1.00 of go-randomdata instead. I simply change v1.1.0 to v1.00 and then run go build again. You will see how the go.mod and go.sumfiles change accordingly.</p>\n<p>Now let’s try running the app again.</p>\n<pre>root@275af4a4091c:~/TestApp# ls<br>TestApp  go.mod  go.sum  main.go<br>root@275af4a4091c:~/TestApp# go run main.go<br>Running the TestApp<br>Oxhorn</pre>\n<p>It works !!</p>\n<p>Now let’s take a look at some other commands that comes with Go modules.</p>\n<p>go mod tidy : This command allows you to fetch all the dependencies that you need for testing in your module.</p>\n<pre>root@275af4a4091c:~/TestApp# go mod tidy<br>go: finding golang.org/x/text/language latest<br>go: finding golang.org/x/text v0.3.0<br>go: downloading golang.org/x/text v0.3.0</pre>\n<p>go mod why -m &lt;module&gt; : This command let’s you find out where any of your dependencies are used. To demonstrate this I will use golang.org/x/text found in my go.mod file.</p>\n<pre>root@275af4a4091c:~/TestApp# go mod why -m golang.org/x/text<br># golang.org/x/text<br>/root/TestApp<br>github.com/Pallinder/go-randomdata<br>github.com/Pallinder/go-randomdata.test<br>golang.org/x/text/language</pre>\n<p>The output shows that<em> golang.org/x/text/language</em> gets consumed by <em>github.com/Pallinder/go-randomdata.test </em>,<em> github.com/Pallinder/go-randomdata</em> is consumed by <em>github.com/Pallinder/go-randomdata</em>.</p>\n<p>Like I mentioned before, Go modules are still in an experimental stage. While it works with Go 1.11, it may not work well with older Go versions. So you might run into a situation that you need to have your vendor files in your repo just to be safe.</p>\n<p>To generate a vendor directory in your app while still maintaining the Go modules you can run go mod vendor</p>\n<pre>root@275af4a4091c:~/TestApp# go mod vendor<br>root@275af4a4091c:~/TestApp# ls<br>TestApp  go.mod  go.sum  main.go  vendor<br>root@275af4a4091c:~/TestApp# ls vendor/<br>github.com  modules.txt</pre>\n<p>Now let’s talk about how to transition into Go modules from the most popular dependency management tool called dep . I used the same application we used in the previous example and used dep instead of go modules. You can find that code base here <a href=\"https://github.com/Niraj-Fonseka/TestAppDep\">https://github.com/Niraj-Fonseka/TestAppDep</a>. I will clone that into my home directory in the container.</p>\n<pre>root@275af4a4091c:~/TestAppDep# ls<br>Gopkg.lock  Gopkg.toml main.go  vendor</pre>\n<p>Now let’s initialize go modules</p>\n<pre>root@275af4a4091c:~/TestAppDep# go mod init<br>go: creating new go.mod: module github.com/Niraj-Fonseka/TestAppDep<br>go: copying requirements from Gopkg.lock</pre>\n<p>And then go mod tidy</p>\n<pre>root@275af4a4091c:~/TestAppDep# go mod tidy<br>go: finding golang.org/x/text/language latest</pre>\n<p>and then delete Gopkg.lock , Gopkg.toml and the vendor directory. Then run go get ./...</p>\n<p>Let’s look at the directory structure now.</p>\n<pre>root@275af4a4091c:~/TestAppDep# ls<br>go.mod go.sum main.go</pre>\n<p>And finally let’s run the app.</p>\n<pre>root@275af4a4091c:~/TestAppDep# go run main.go<br>Running the TestApp<br>Edgeorange</pre>\n<p>That’s it. Hopefully this will give you a basic understanding on how to get started with Go modules. If you would like to learn more about Go modules I would suggest looking at the Go release notes for go 1.11 and <a href=\"https://github.com/golang/go/wiki/Modules\">https://github.com/golang/go/wiki/Modules</a>. Also <a href=\"https://campoy.cat/\">Francesc Campoy</a>, an ex developer advocate for Golang, has an amazing video series called <a href=\"https://www.youtube.com/channel/UC_BzFbxG2za3bp5NRRRXJSw\">justforfunc</a> where goes a lot more in-depth into Go modules and many other Go related topics.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b3dac652066d\" width=\"1\" height=\"1\" alt=\"\">\n",
            "content": "\n<h3>Getting started with Go modules</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*OJczjavmA1kqrdY_97UvDQ.png\"></figure><p>Golang is still a fairly new programming language. And dependency management for Go has been a bit tricky since its inception. At the beginning, there was no dependency management system.go get was the only way to download dependencies but this became very tricky because this pulls the code from the master branch of a repository and puts the files into your GOPATH. That means if there were any major changes to any dependencies there’s high likelihood that your code will break. Then tools like dep and concepts such as vendoring came along. Personally I liked dep because it took away a lot of the headaches that came with using go get . But dep was still a third party tool that you had to download to get it to work. But now, with go 1.11things are finally changing.</p>\n<p><strong>So what are Go modules ?</strong></p>\n<p>Go modules in a nutshell is a built-in dependency versioning and dependency management feature for Go. Please note that this is still in experimental stage and the the finalized version will come with go 1.12 .</p>\n<p>In this article I will show you how Go modules work. And also how to move to Go modules if you are currently using dep as your dependency management tool.</p>\n<p>First of all, you will need to make sure that you have Go 1.11 installed. But if you are a fan of docker and don’t want to install Go 1.11 right now you can spin up a Go 1.11 container and use that to play around with Go modules. Also don’t forget to install a text editor when you get inside the docker container.</p>\n<pre>docker run --rm -it golang:1.11</pre>\n<pre>//after you get inside the container </pre>\n<pre>apt-get update &amp;&amp; apt-get install nano</pre>\n<p><strong>Our first application !</strong></p>\n<p>Inside the container you can see that the go path is set to /go</p>\n<pre>root@275af4a4091c:~# echo $GOPATH<br>/go</pre>\n<p>But I’m going to try something that would’ve been very wrong to do in previous Go versions. I’m going to go into my home directory and create a folder for our app called TestApp and set up my app there instead of inside GOPATH.</p>\n<pre>root@275af4a4091c:~# mkdir TestApp<br>root@275af4a4091c:~# ls<br>TestApp</pre>\n<p>Now let’s write our application inside the TestApp folder and name it main.go</p>\n<pre>package main</pre>\n<pre>import (<br> \"fmt\"<br>)</pre>\n<pre>func main(){<br> fmt.Println(\"Running the TestApp\")<br>}</pre>\n<p>Now let’s run it.</p>\n<pre>root@275af4a4091c:~/TestApp# go run main.go<br>Running the TestApp</pre>\n<p>That’s right !! Now we can run Go programs outside of GOPATH !! But this app runs without throwing any errors because it’s only using the fmt library. But let’s try adding a third party library and see how that plays out. I’ll be using <a href=\"https://github.com/Pallinder/go-randomdata\">go-randomdata</a> as our third party library. It lets you generate random data. In this case I’m going to call the function SillyName() after the first print statement.</p>\n<p>This is how the update code looks like.</p>\n<pre>package main</pre>\n<pre>import (<br>        \"fmt\"<br>        \"github.com/Pallinder/go-randomdata\"<br>)</pre>\n<pre>func main(){<br>        fmt.Println(\"Running the TestApp\")<br>        fmt.Println(randomdata.SillyName())<br>}</pre>\n<p>Let’s now run it.</p>\n<pre>root@275af4a4091c:~/TestApp# go run main.go<br>main.go:5:2: cannot find package \"github.com/Pallinder/go-randomdata\" in any of:<br> /usr/local/go/src/github.com/Pallinder/go-randomdata (from $GOROOT)<br> /go/src/github.com/Pallinder/go-randomdata (from $GOPATH)</pre>\n<p>It complains about not finding the package because #1 we are outside of the GOPATH and #2 we haven’t downloaded that package yet. Let’s see how we can use Go modules to fix this. To initialize Go modules in to your application you can run go modules init /path/to/directory</p>\n<pre>root@275af4a4091c:~/TestApp# go mod init /root/TestApp<br>go: creating new go.mod: module /root/TestApp</pre>\n<p>You will see a new file called go.mod gets created in your app directory. Apart from the definition of the module there’s nothing in the go.mod at the moment. To get all the dependencies lets run go build</p>\n<pre>root@275af4a4091c:~/TestApp# go build<br>go: finding github.com/Pallinder/go-randomdata v1.1.0<br>go: downloading github.com/Pallinder/go-randomdata v1.1.0</pre>\n<p>Now let’s take a look at the go.mod file.</p>\n<pre>module /root/TestApp</pre>\n<pre>require github.com/Pallinder/go-randomdata v1.1.0</pre>\n<p>It shows us that in order for our app to run, v1.1.0 is required of the go-randomdata package. After running go build you will also see a file called go.sum gets created. The purpose of this file is to keep track of which codebase of the package you are using. It has a cryptographic hash attached to every dependency we have. This is very helpful if you are working on a busy codebase that multiple people are working on at the same time. If someone is using a different version of a package than the version the app is intended to use, it will complain. If your third party library has multiple versions and you would like to use a different version, you can change the version number and run go build again. Let’s say I would like to use v1.00 of go-randomdata instead. I simply change v1.1.0 to v1.00 and then run go build again. You will see how the go.mod and go.sumfiles change accordingly.</p>\n<p>Now let’s try running the app again.</p>\n<pre>root@275af4a4091c:~/TestApp# ls<br>TestApp  go.mod  go.sum  main.go<br>root@275af4a4091c:~/TestApp# go run main.go<br>Running the TestApp<br>Oxhorn</pre>\n<p>It works !!</p>\n<p>Now let’s take a look at some other commands that comes with Go modules.</p>\n<p>go mod tidy : This command allows you to fetch all the dependencies that you need for testing in your module.</p>\n<pre>root@275af4a4091c:~/TestApp# go mod tidy<br>go: finding golang.org/x/text/language latest<br>go: finding golang.org/x/text v0.3.0<br>go: downloading golang.org/x/text v0.3.0</pre>\n<p>go mod why -m &lt;module&gt; : This command let’s you find out where any of your dependencies are used. To demonstrate this I will use golang.org/x/text found in my go.mod file.</p>\n<pre>root@275af4a4091c:~/TestApp# go mod why -m golang.org/x/text<br># golang.org/x/text<br>/root/TestApp<br>github.com/Pallinder/go-randomdata<br>github.com/Pallinder/go-randomdata.test<br>golang.org/x/text/language</pre>\n<p>The output shows that<em> golang.org/x/text/language</em> gets consumed by <em>github.com/Pallinder/go-randomdata.test </em>,<em> github.com/Pallinder/go-randomdata</em> is consumed by <em>github.com/Pallinder/go-randomdata</em>.</p>\n<p>Like I mentioned before, Go modules are still in an experimental stage. While it works with Go 1.11, it may not work well with older Go versions. So you might run into a situation that you need to have your vendor files in your repo just to be safe.</p>\n<p>To generate a vendor directory in your app while still maintaining the Go modules you can run go mod vendor</p>\n<pre>root@275af4a4091c:~/TestApp# go mod vendor<br>root@275af4a4091c:~/TestApp# ls<br>TestApp  go.mod  go.sum  main.go  vendor<br>root@275af4a4091c:~/TestApp# ls vendor/<br>github.com  modules.txt</pre>\n<p>Now let’s talk about how to transition into Go modules from the most popular dependency management tool called dep . I used the same application we used in the previous example and used dep instead of go modules. You can find that code base here <a href=\"https://github.com/Niraj-Fonseka/TestAppDep\">https://github.com/Niraj-Fonseka/TestAppDep</a>. I will clone that into my home directory in the container.</p>\n<pre>root@275af4a4091c:~/TestAppDep# ls<br>Gopkg.lock  Gopkg.toml main.go  vendor</pre>\n<p>Now let’s initialize go modules</p>\n<pre>root@275af4a4091c:~/TestAppDep# go mod init<br>go: creating new go.mod: module github.com/Niraj-Fonseka/TestAppDep<br>go: copying requirements from Gopkg.lock</pre>\n<p>And then go mod tidy</p>\n<pre>root@275af4a4091c:~/TestAppDep# go mod tidy<br>go: finding golang.org/x/text/language latest</pre>\n<p>and then delete Gopkg.lock , Gopkg.toml and the vendor directory. Then run go get ./...</p>\n<p>Let’s look at the directory structure now.</p>\n<pre>root@275af4a4091c:~/TestAppDep# ls<br>go.mod go.sum main.go</pre>\n<p>And finally let’s run the app.</p>\n<pre>root@275af4a4091c:~/TestAppDep# go run main.go<br>Running the TestApp<br>Edgeorange</pre>\n<p>That’s it. Hopefully this will give you a basic understanding on how to get started with Go modules. If you would like to learn more about Go modules I would suggest looking at the Go release notes for go 1.11 and <a href=\"https://github.com/golang/go/wiki/Modules\">https://github.com/golang/go/wiki/Modules</a>. Also <a href=\"https://campoy.cat/\">Francesc Campoy</a>, an ex developer advocate for Golang, has an amazing video series called <a href=\"https://www.youtube.com/channel/UC_BzFbxG2za3bp5NRRRXJSw\">justforfunc</a> where goes a lot more in-depth into Go modules and many other Go related topics.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b3dac652066d\" width=\"1\" height=\"1\" alt=\"\">\n",
            "enclosure": {},
            "categories": [
                "dependencies",
                "technology",
                "go",
                "golang",
                "programming"
            ]
        },
        {
            "title": "How to maintain the order of Go Routines",
            "pubDate": "2018-12-03 03:13:35",
            "link": "https://medium.com/@fonseka.live/how-to-maintain-the-order-of-go-routines-117a5be86c4f?source=rss-d76a6b2861ea------2",
            "guid": "https://medium.com/p/117a5be86c4f",
            "author": "Niraj Fonseka",
            "thumbnail": "https://cdn-images-1.medium.com/max/1024/1*e6d4XXctN8drBR3RI7S1DQ.png",
            "description": "\n<p>Go programming language is popular for how it handles concurrency. This short article is written with the assumption that you already have a basic understanding of what Go routines and Channels are. But in a nutshell go routines can be thought of as lightweight “threads” that can be run concurrently with other Go routines ( <a href=\"https://golangbot.com/goroutines/\">https://golangbot.com/goroutines/</a> ). Channels are used to the communicate through and between Go routines.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*e6d4XXctN8drBR3RI7S1DQ.png\"></figure><p><strong>Implementation #1</strong></p>\n<p>Let’s assume that I have four functions to execute. First function takes 7 seconds to finish, Second function takes 5 seconds , Third takes 2 seconds and the Fourth function a whopping 10 seconds. The goal is to run these functions at the shortest amount of time possible. First let’s try running these functions sequentially.</p>\n<a href=\"https://medium.com/media/5d72fe43b75bd6058b857e3fe3b2bff0/href\">https://medium.com/media/5d72fe43b75bd6058b857e3fe3b2bff0/href</a><p>The results show us that it took total of 24 seconds for all the four functions to execute.</p>\n<pre>-- Executing first function --<br>-- First Function finished --<br>-- Executing second function --<br>-- Second Function finished --<br>-- Executing third function --<br>-- Third Function finished --<br>-- Executing fourth function --<br>-- Fourth Function finished --<br>Total time to finish : 24.0017815s</pre>\n<p><strong>Implementation #2</strong></p>\n<p>Now I want to run these functions concurrently with each other. So make each function a Go routine and see how things play out.</p>\n<a href=\"https://medium.com/media/57562915b8efcb352b9acb3b7f37a922/href\">https://medium.com/media/57562915b8efcb352b9acb3b7f37a922/href</a><p>In this implementation I managed to run all the four functions concurrently. I used a Waitgroup to make sure all the Go routines have finished executing. If you are not familiar with sync.WaitGroup this article will be helpful. <a href=\"https://nanxiao.me/en/use-sync-waitgroup-in-golang/\">https://nanxiao.me/en/use-sync-waitgroup-in-golang/</a></p>\n<p>Now let’s take a look at the results.</p>\n<pre>-- Executing fourth function --<br>-- Executing second function --<br>-- Executing first function --<br>-- Executing third function --<br>-- Third Function finished --<br>-- Second Function finished --<br>-- First Function finished --<br>-- Fourth Function finished --<br>Total time to finish : 10.0008306s</pre>\n<p>Great ! We were able to get all the functions to finish in 10 seconds. Compared to 24 seconds in the previous example. But wait.. the order the go routines printed out their responses is wrong. So we are still not done.</p>\n<p><strong>Implementation #3</strong></p>\n<a href=\"https://medium.com/media/92797d0bf1111e89d4568bcdfd4165c3/href\">https://medium.com/media/92797d0bf1111e89d4568bcdfd4165c3/href</a><p>In this implementation I have created a channel per function and passed those channels into their corresponding functions. And whenever a function finish executing it will push its output into the channel that is passed in. Then in the main function I’m extracting the value from each channel in order that I would like the output to be in. Let’s look at the output now.</p>\n<pre>-- Executing second function --<br>-- Executing third function --<br>-- Executing first function --<br>-- Executing fourth function --<br>-- First Function finished --<br>-- Second Function finished --<br>-- Third Function finished --<br>-- Fourth Function finished --<br>Total time to finish : 10.0008523</pre>\n<p>In this case all the four functions started executing at the same time. But unlike the implementation #2 we were able to extract the output in the correct order and still finish executing all the functions in 10 seconds.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=117a5be86c4f\" width=\"1\" height=\"1\" alt=\"\">\n",
            "content": "\n<p>Go programming language is popular for how it handles concurrency. This short article is written with the assumption that you already have a basic understanding of what Go routines and Channels are. But in a nutshell go routines can be thought of as lightweight “threads” that can be run concurrently with other Go routines ( <a href=\"https://golangbot.com/goroutines/\">https://golangbot.com/goroutines/</a> ). Channels are used to the communicate through and between Go routines.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*e6d4XXctN8drBR3RI7S1DQ.png\"></figure><p><strong>Implementation #1</strong></p>\n<p>Let’s assume that I have four functions to execute. First function takes 7 seconds to finish, Second function takes 5 seconds , Third takes 2 seconds and the Fourth function a whopping 10 seconds. The goal is to run these functions at the shortest amount of time possible. First let’s try running these functions sequentially.</p>\n<a href=\"https://medium.com/media/5d72fe43b75bd6058b857e3fe3b2bff0/href\">https://medium.com/media/5d72fe43b75bd6058b857e3fe3b2bff0/href</a><p>The results show us that it took total of 24 seconds for all the four functions to execute.</p>\n<pre>-- Executing first function --<br>-- First Function finished --<br>-- Executing second function --<br>-- Second Function finished --<br>-- Executing third function --<br>-- Third Function finished --<br>-- Executing fourth function --<br>-- Fourth Function finished --<br>Total time to finish : 24.0017815s</pre>\n<p><strong>Implementation #2</strong></p>\n<p>Now I want to run these functions concurrently with each other. So make each function a Go routine and see how things play out.</p>\n<a href=\"https://medium.com/media/57562915b8efcb352b9acb3b7f37a922/href\">https://medium.com/media/57562915b8efcb352b9acb3b7f37a922/href</a><p>In this implementation I managed to run all the four functions concurrently. I used a Waitgroup to make sure all the Go routines have finished executing. If you are not familiar with sync.WaitGroup this article will be helpful. <a href=\"https://nanxiao.me/en/use-sync-waitgroup-in-golang/\">https://nanxiao.me/en/use-sync-waitgroup-in-golang/</a></p>\n<p>Now let’s take a look at the results.</p>\n<pre>-- Executing fourth function --<br>-- Executing second function --<br>-- Executing first function --<br>-- Executing third function --<br>-- Third Function finished --<br>-- Second Function finished --<br>-- First Function finished --<br>-- Fourth Function finished --<br>Total time to finish : 10.0008306s</pre>\n<p>Great ! We were able to get all the functions to finish in 10 seconds. Compared to 24 seconds in the previous example. But wait.. the order the go routines printed out their responses is wrong. So we are still not done.</p>\n<p><strong>Implementation #3</strong></p>\n<a href=\"https://medium.com/media/92797d0bf1111e89d4568bcdfd4165c3/href\">https://medium.com/media/92797d0bf1111e89d4568bcdfd4165c3/href</a><p>In this implementation I have created a channel per function and passed those channels into their corresponding functions. And whenever a function finish executing it will push its output into the channel that is passed in. Then in the main function I’m extracting the value from each channel in order that I would like the output to be in. Let’s look at the output now.</p>\n<pre>-- Executing second function --<br>-- Executing third function --<br>-- Executing first function --<br>-- Executing fourth function --<br>-- First Function finished --<br>-- Second Function finished --<br>-- Third Function finished --<br>-- Fourth Function finished --<br>Total time to finish : 10.0008523</pre>\n<p>In this case all the four functions started executing at the same time. But unlike the implementation #2 we were able to extract the output in the correct order and still finish executing all the functions in 10 seconds.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=117a5be86c4f\" width=\"1\" height=\"1\" alt=\"\">\n",
            "enclosure": {},
            "categories": [
                "programming",
                "concurrency",
                "goroutines",
                "golang",
                "technology"
            ]
        },
        {
            "title": "How I saved money with Go",
            "pubDate": "2018-11-11 02:23:45",
            "link": "https://medium.com/@fonseka.live/how-i-saved-money-with-go-ad9d774ee060?source=rss-d76a6b2861ea------2",
            "guid": "https://medium.com/p/ad9d774ee060",
            "author": "Niraj Fonseka",
            "thumbnail": "https://cdn-images-1.medium.com/max/1024/1*pMX3NF79wHVY6BrewKiC7A.png",
            "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*pMX3NF79wHVY6BrewKiC7A.png\"></figure><p>As a software developer, you will constantly find yourself having to deal with databases, third party applications and other services. And sometimes if the application you are developing is expecting a large amount of activity then you will have to think twice about the architecture of your application because every application won’t behave the same when it’s at scale. Therefore it’s highly likely that you will find yourself in situation where you’d want to reduce the amount of connections you open with your database, reduce the number of time you call that costly third party service etc. I was in the same situation. So I will walk you through a solution I found that will be helpful in these kind of scenarios.</p>\n<p>First of all let’s look at a simple go web server.</p>\n<p><strong>Example 1</strong></p>\n<pre>package main</pre>\n<pre>import (<br>   \"fmt\"<br>   \"io\"<br>   \"log\"<br>   \"net/http\"<br>   \"time\"<br>)</pre>\n<pre>var cost int64</pre>\n<pre>func main() {</pre>\n<pre>    http.HandleFunc(\"/fetch_data\", GetDataHandler)</pre>\n<pre>    log.Println(\"Serving Port :  8000\")</pre>\n<pre>    http.ListenAndServe(\":8000\", nil)</pre>\n<pre>}<br></pre>\n<pre>func GetDataHandler(w http.ResponseWriter, r *http.Request) {</pre>\n<pre>    fmt.Println(r.URL)</pre>\n<pre>    data, _ := GetData()</pre>\n<pre>    io.WriteString(w, data)</pre>\n<pre>}</pre>\n<pre>func GetData() (string, error) {</pre>\n<pre>    time.Sleep(5 * time.Second)</pre>\n<pre>    cost += 100</pre>\n<pre>    fmt.Printf(\"Cost : %d \\n\", cost)</pre>\n<pre>    return fmt.Sprintf(\"Fetch called : %d\", cost), nil <br>}</pre>\n<p>This server has an endpoint called /fetch_data that will trigger a function call GetData(). Let’s assume this GetData() function represents the database call or the third-party call that we would like to make. In that GetData() function I’ve made it sleep for 5 seconds to make the call more realistic. Also every time this function is invoked, the global variable cost is incremented by 100. This is to show that every call to GetData() costs us $100.</p>\n<p>To test how our server handles under heavy traffic, I’ll be using a load testing tool ( that’s also written in Go ) called, Vegeta ( <a href=\"https://github.com/tsenart/vegeta\">https://github.com/tsenart/vegeta</a> ). As our first test, I’ll be calling the /fetch_data endpoint for 5 seconds with a rate of 10 requests per second. Now let’s run the test.</p>\n<pre>vegeta attack -targets=targets_normal.txt -duration=5s -rate=10 | tee results_normal.bin | vegeta report</pre>\n<p>targets_normal.txt contains the REST methods and the URLs that are being tested.</p>\n<pre>GET <a href=\"http://localhost:8000/fetch_data\">http://localhost:8000/fetch_data</a></pre>\n<p>Now let’s take a look at the results.</p>\n<pre>Requests      [total, rate]            50, 10.20<br>Duration      [total, attack, wait]    9.909676807s, 4.903610868s, 5.006065939s<br>Latencies     [mean, 50, 95, 99, max]  5.005698559s, 5.006212501s, 5.008185721s, 5.013624665s, 5.013624665s<br>Bytes In      [total, mean]            941, 18.82<br>Bytes Out     [total, mean]            0, 0.00<br>Success       [ratio]                  100.00%<br>Status Codes  [code:count]             200:50<br>Error Set:</pre>\n<p>the results show 50 successful requests are executed. And if we take a look at the server logs, we can see that the total cost for these 50 requests was <strong>$5000</strong>. The current design of the application invokes GetData() every time when a request comes in even if every request is the exact same. What if we can execute the GetData() function once and satisfy all the requests ?</p>\n<p>This is where the sync/singleflight package comes in handy.</p>\n<p><strong>Example 2</strong></p>\n<pre>package main</pre>\n<pre>import (</pre>\n<pre>\"fmt\"<br>\"io\"<br>\"log\"<br>\"net/http\"<br>\"time\"<br>\"golang.org/x/sync/singleflight\"</pre>\n<pre>)</pre>\n<pre>var cost int64</pre>\n<pre>func main() {</pre>\n<pre>   var requestGroup singleflight.Group</pre>\n<pre>   http.HandleFunc(\"/fetch_data\", RequestGroup{r:     &amp;requestGroup}.GetDataHandler)</pre>\n<pre>   log.Println(\"Serving Port :  8001\")</pre>\n<pre>   http.ListenAndServe(\":8001\", nil)</pre>\n<pre>}</pre>\n<pre>type RequestGroup struct {<br>    r *singleflight.Group<br>}</pre>\n<pre>func (rg RequestGroup) GetDataHandler(w http.ResponseWriter, r *http.Request) {</pre>\n<pre>   fmt.Println(r.URL)</pre>\n<pre>   value, err, _ := rg.r.Do(r.URL.String(), func() (interface{}, error) {</pre>\n<pre>       go func() {</pre>\n<pre>          time.Sleep(5000 * time.Millisecond)</pre>\n<pre>          rg.r.Forget(r.URL.String())</pre>\n<pre>       }()</pre>\n<pre>      return GetData()</pre>\n<pre>   })</pre>\n<pre>   if err != nil {</pre>\n<pre>   http.Error(w, err.Error(), http.StatusInternalServerError)</pre>\n<pre>   return</pre>\n<pre>}</pre>\n<pre>   data := value.(string)</pre>\n<pre>   io.WriteString(w, data)</pre>\n<pre>}</pre>\n<pre>func GetData() (string, error) {</pre>\n<pre>   time.Sleep(5 * time.Second)</pre>\n<pre>   cost += 100</pre>\n<pre>   fmt.Printf(\"Cost : %d \\n\", cost)</pre>\n<pre>   return fmt.Sprintf(\"Fetch called : %d\", cost), nil</pre>\n<pre>}</pre>\n<p>We will be using the Do() function in the singleflight package. The Do() function takes in a string as the key and a function that returns an error and an interface as inputs. Singleflight will make sure for a given key only one execution of the function that was passed in happens. As for the key I will be using the URL of the request. In this case it will be /fetch_data. In the Do() function we will spin up a go routine in the background and then ask singleflight to forget the request after 5 seconds. This means that any request that comes within the 5 seconds of the first request gets in will be served with the same response from the GetData() function.</p>\n<p>Now let’s run the same load test and see how the application behaves.</p>\n<pre>vegeta attack -targets=targets_singleflight.txt -duration=5s -rate=10 | tee results_singleflight.bin | vegeta report</pre>\n<p>Let’s take a look at the results.</p>\n<pre>Requests      [total, rate]            50, 10.20<br>Duration      [total, attack, wait]    5.014053656s, 4.900833893s, 113.219763ms<br>Latencies     [mean, 50, 95, 99, max]  2.561878061s, 2.560777702s, 4.8108588s, 5.013957585s, 5.013957585s<br>Bytes In      [total, mean]            900, 18.00<br>Bytes Out     [total, mean]            0, 0.00<br>Success       [ratio]                  100.00%<br>Status Codes  [code:count]             200:50<br>Error Set:</pre>\n<p>Things looks pretty similar ( although the test on the server with singleflight took less time to process 100 requests. Which is a good thing :) ) compared to the previous test. But when we check the server logs we can see that compared to the $5000 this time we have only spent <strong>$100</strong>. That’s a pretty significant cost saving. Let’s run a load test for 10 seconds for both of the apps.</p>\n<pre>---- Starting attack -----</pre>\n<pre>---- Attacking Datasource Server ----<br>Requests      [total, rate]            100, 10.10<br>Duration      [total, attack, wait]    14.904334343s, 9.902888604s, 5.001445739s<br>Latencies     [mean, 50, 95, 99, max]  5.00261956s, 5.002215223s, 5.00566831s, 5.009361413s, 5.012719579s<br>Bytes In      [total, mean]            1892, 18.92<br>Bytes Out     [total, mean]            0, 0.00<br>Success       [ratio]                  100.00%<br>Status Codes  [code:count]             200:100<br>Error Set:</pre>\n<pre>---- Attacking Datasource with singleflight ----<br>Requests      [total, rate]            100, 10.10<br>Duration      [total, attack, wait]    10.106814205s, 9.903963803s, 202.850402ms<br>Latencies     [mean, 50, 95, 99, max]  2.555588866s, 2.556200382s, 4.807365963s, 5.008225608s, 5.014383781s<br>Bytes In      [total, mean]            1800, 18.00<br>Bytes Out     [total, mean]            0, 0.00<br>Success       [ratio]                  100.00%<br>Status Codes  [code:count]             200:100<br>Error Set:</pre>\n<pre>---- Ending  attack -----</pre>\n<p>In this case the application without singleflight ended up costing us <strong>$10000 </strong>while the other with singleflight only cost $200</p>\n<p>Final Thoughts ..</p>\n<p>I was very surprised to find out how there are only few examples / articles about this package. Hopefully you will find this article helpful in your daily problem solving adventures.</p>\n<p>All the code in for this article is in this <a href=\"https://github.com/Niraj-Fonseka/SavingMoneyWithGo\">repository</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ad9d774ee060\" width=\"1\" height=\"1\" alt=\"\">\n",
            "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*pMX3NF79wHVY6BrewKiC7A.png\"></figure><p>As a software developer, you will constantly find yourself having to deal with databases, third party applications and other services. And sometimes if the application you are developing is expecting a large amount of activity then you will have to think twice about the architecture of your application because every application won’t behave the same when it’s at scale. Therefore it’s highly likely that you will find yourself in situation where you’d want to reduce the amount of connections you open with your database, reduce the number of time you call that costly third party service etc. I was in the same situation. So I will walk you through a solution I found that will be helpful in these kind of scenarios.</p>\n<p>First of all let’s look at a simple go web server.</p>\n<p><strong>Example 1</strong></p>\n<pre>package main</pre>\n<pre>import (<br>   \"fmt\"<br>   \"io\"<br>   \"log\"<br>   \"net/http\"<br>   \"time\"<br>)</pre>\n<pre>var cost int64</pre>\n<pre>func main() {</pre>\n<pre>    http.HandleFunc(\"/fetch_data\", GetDataHandler)</pre>\n<pre>    log.Println(\"Serving Port :  8000\")</pre>\n<pre>    http.ListenAndServe(\":8000\", nil)</pre>\n<pre>}<br></pre>\n<pre>func GetDataHandler(w http.ResponseWriter, r *http.Request) {</pre>\n<pre>    fmt.Println(r.URL)</pre>\n<pre>    data, _ := GetData()</pre>\n<pre>    io.WriteString(w, data)</pre>\n<pre>}</pre>\n<pre>func GetData() (string, error) {</pre>\n<pre>    time.Sleep(5 * time.Second)</pre>\n<pre>    cost += 100</pre>\n<pre>    fmt.Printf(\"Cost : %d \\n\", cost)</pre>\n<pre>    return fmt.Sprintf(\"Fetch called : %d\", cost), nil <br>}</pre>\n<p>This server has an endpoint called /fetch_data that will trigger a function call GetData(). Let’s assume this GetData() function represents the database call or the third-party call that we would like to make. In that GetData() function I’ve made it sleep for 5 seconds to make the call more realistic. Also every time this function is invoked, the global variable cost is incremented by 100. This is to show that every call to GetData() costs us $100.</p>\n<p>To test how our server handles under heavy traffic, I’ll be using a load testing tool ( that’s also written in Go ) called, Vegeta ( <a href=\"https://github.com/tsenart/vegeta\">https://github.com/tsenart/vegeta</a> ). As our first test, I’ll be calling the /fetch_data endpoint for 5 seconds with a rate of 10 requests per second. Now let’s run the test.</p>\n<pre>vegeta attack -targets=targets_normal.txt -duration=5s -rate=10 | tee results_normal.bin | vegeta report</pre>\n<p>targets_normal.txt contains the REST methods and the URLs that are being tested.</p>\n<pre>GET <a href=\"http://localhost:8000/fetch_data\">http://localhost:8000/fetch_data</a></pre>\n<p>Now let’s take a look at the results.</p>\n<pre>Requests      [total, rate]            50, 10.20<br>Duration      [total, attack, wait]    9.909676807s, 4.903610868s, 5.006065939s<br>Latencies     [mean, 50, 95, 99, max]  5.005698559s, 5.006212501s, 5.008185721s, 5.013624665s, 5.013624665s<br>Bytes In      [total, mean]            941, 18.82<br>Bytes Out     [total, mean]            0, 0.00<br>Success       [ratio]                  100.00%<br>Status Codes  [code:count]             200:50<br>Error Set:</pre>\n<p>the results show 50 successful requests are executed. And if we take a look at the server logs, we can see that the total cost for these 50 requests was <strong>$5000</strong>. The current design of the application invokes GetData() every time when a request comes in even if every request is the exact same. What if we can execute the GetData() function once and satisfy all the requests ?</p>\n<p>This is where the sync/singleflight package comes in handy.</p>\n<p><strong>Example 2</strong></p>\n<pre>package main</pre>\n<pre>import (</pre>\n<pre>\"fmt\"<br>\"io\"<br>\"log\"<br>\"net/http\"<br>\"time\"<br>\"golang.org/x/sync/singleflight\"</pre>\n<pre>)</pre>\n<pre>var cost int64</pre>\n<pre>func main() {</pre>\n<pre>   var requestGroup singleflight.Group</pre>\n<pre>   http.HandleFunc(\"/fetch_data\", RequestGroup{r:     &amp;requestGroup}.GetDataHandler)</pre>\n<pre>   log.Println(\"Serving Port :  8001\")</pre>\n<pre>   http.ListenAndServe(\":8001\", nil)</pre>\n<pre>}</pre>\n<pre>type RequestGroup struct {<br>    r *singleflight.Group<br>}</pre>\n<pre>func (rg RequestGroup) GetDataHandler(w http.ResponseWriter, r *http.Request) {</pre>\n<pre>   fmt.Println(r.URL)</pre>\n<pre>   value, err, _ := rg.r.Do(r.URL.String(), func() (interface{}, error) {</pre>\n<pre>       go func() {</pre>\n<pre>          time.Sleep(5000 * time.Millisecond)</pre>\n<pre>          rg.r.Forget(r.URL.String())</pre>\n<pre>       }()</pre>\n<pre>      return GetData()</pre>\n<pre>   })</pre>\n<pre>   if err != nil {</pre>\n<pre>   http.Error(w, err.Error(), http.StatusInternalServerError)</pre>\n<pre>   return</pre>\n<pre>}</pre>\n<pre>   data := value.(string)</pre>\n<pre>   io.WriteString(w, data)</pre>\n<pre>}</pre>\n<pre>func GetData() (string, error) {</pre>\n<pre>   time.Sleep(5 * time.Second)</pre>\n<pre>   cost += 100</pre>\n<pre>   fmt.Printf(\"Cost : %d \\n\", cost)</pre>\n<pre>   return fmt.Sprintf(\"Fetch called : %d\", cost), nil</pre>\n<pre>}</pre>\n<p>We will be using the Do() function in the singleflight package. The Do() function takes in a string as the key and a function that returns an error and an interface as inputs. Singleflight will make sure for a given key only one execution of the function that was passed in happens. As for the key I will be using the URL of the request. In this case it will be /fetch_data. In the Do() function we will spin up a go routine in the background and then ask singleflight to forget the request after 5 seconds. This means that any request that comes within the 5 seconds of the first request gets in will be served with the same response from the GetData() function.</p>\n<p>Now let’s run the same load test and see how the application behaves.</p>\n<pre>vegeta attack -targets=targets_singleflight.txt -duration=5s -rate=10 | tee results_singleflight.bin | vegeta report</pre>\n<p>Let’s take a look at the results.</p>\n<pre>Requests      [total, rate]            50, 10.20<br>Duration      [total, attack, wait]    5.014053656s, 4.900833893s, 113.219763ms<br>Latencies     [mean, 50, 95, 99, max]  2.561878061s, 2.560777702s, 4.8108588s, 5.013957585s, 5.013957585s<br>Bytes In      [total, mean]            900, 18.00<br>Bytes Out     [total, mean]            0, 0.00<br>Success       [ratio]                  100.00%<br>Status Codes  [code:count]             200:50<br>Error Set:</pre>\n<p>Things looks pretty similar ( although the test on the server with singleflight took less time to process 100 requests. Which is a good thing :) ) compared to the previous test. But when we check the server logs we can see that compared to the $5000 this time we have only spent <strong>$100</strong>. That’s a pretty significant cost saving. Let’s run a load test for 10 seconds for both of the apps.</p>\n<pre>---- Starting attack -----</pre>\n<pre>---- Attacking Datasource Server ----<br>Requests      [total, rate]            100, 10.10<br>Duration      [total, attack, wait]    14.904334343s, 9.902888604s, 5.001445739s<br>Latencies     [mean, 50, 95, 99, max]  5.00261956s, 5.002215223s, 5.00566831s, 5.009361413s, 5.012719579s<br>Bytes In      [total, mean]            1892, 18.92<br>Bytes Out     [total, mean]            0, 0.00<br>Success       [ratio]                  100.00%<br>Status Codes  [code:count]             200:100<br>Error Set:</pre>\n<pre>---- Attacking Datasource with singleflight ----<br>Requests      [total, rate]            100, 10.10<br>Duration      [total, attack, wait]    10.106814205s, 9.903963803s, 202.850402ms<br>Latencies     [mean, 50, 95, 99, max]  2.555588866s, 2.556200382s, 4.807365963s, 5.008225608s, 5.014383781s<br>Bytes In      [total, mean]            1800, 18.00<br>Bytes Out     [total, mean]            0, 0.00<br>Success       [ratio]                  100.00%<br>Status Codes  [code:count]             200:100<br>Error Set:</pre>\n<pre>---- Ending  attack -----</pre>\n<p>In this case the application without singleflight ended up costing us <strong>$10000 </strong>while the other with singleflight only cost $200</p>\n<p>Final Thoughts ..</p>\n<p>I was very surprised to find out how there are only few examples / articles about this package. Hopefully you will find this article helpful in your daily problem solving adventures.</p>\n<p>All the code in for this article is in this <a href=\"https://github.com/Niraj-Fonseka/SavingMoneyWithGo\">repository</a>.</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=ad9d774ee060\" width=\"1\" height=\"1\" alt=\"\">\n",
            "enclosure": {},
            "categories": [
                "concurrency",
                "programming",
                "computer-science",
                "golang",
                "goroutines"
            ]
        }
    ]
}